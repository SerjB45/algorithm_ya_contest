# ID посылки: 143429681

# Шифрованные инструкции
# Описание задачи:
# Марсоход получает с Земли сокращённые инструкции с заданиями, например:
# с — сделать снимок;
# в — взять образец грунта;
# ш — сделать шаг;
# о — включить освещение;

# Инструкции отправляются в сжатом виде. Если нужно сделать 10 снимков подряд,
# то инструкция будет выглядеть как 10[с]. Число перед квадратными скобками
# обозначает сколько раз надо повторить последовательность внутри скобок.
# Скобки могут быть вложенными: 2[ш3[с]]10[с].

# Командный центр отправляет сжатую строку инструкций, а марсоход получает
# и расшифровывает её в полную последовательность команд. Команды могут
# обозначаться символами латиницы или кириллицы.
# Пример Команда: 2[в3[ш]]с -> Расшифровка: «вшшшвшшшс»

# Формат ввода
# Сокращенная форма команды. Например, 3[a]2[bc].
# - Гарантированно приходит валидная строка.
# - В строке могут быть только буквы, числа и квадратные скобки.
# - Длина строки может находиться в диапазоне от 0 (пустая строка) до 30
# символов включительно. Числа в строке могут быть от 1 до 300 включительно.

# Формат вывода
# Полная форма команды. Например, aaabcbc.

NUMBERS_TEMPLATE = '1234567890'


def get_decipher_command(short_command: str) -> str:
    """
    Преобразование сокращенной комманды в полную.
    Описание алгоритма:
    1. В функцию decipher_command передается короткая команда. В ней объявлено
    два list(используем как стеки), которые нужны для формирования
    повторяющихся последовательностей комманд (2[bc]->bcbc)
    2. В Функции происходит посимвольная обработка полученной комманды.
    2.1  Если символ - число, то начинаем конкатенацией "собирать" полный
    множитель комманды multiplier(может состоять из нескольких символов).
    2.2 Cимвол == [ - это началась обработка дублирующейся, в стеки сохраняем
    уже обработанную часть комманды и количество повторений комманды в []
    2.3 Cимвол == ] - завершилась обработка дублирующейся комманды, собираем
    полную комманду, используя данные записанные в стеки
    2.4 Остальные случаи - обработка букв, сборка комманды
    3. Обработав все символы в decipher_command возвращаем полную комманду
    command
    """

    multiplier = ''
    multiplier_stack = []
    command_stack = []
    command = ''
    for symbol in short_command:
        if symbol in NUMBERS_TEMPLATE:
            multiplier += symbol
        elif symbol == '[':
            multiplier_stack.append(int(multiplier))
            command_stack.append(command)
            multiplier = ''
            command = ''
        elif symbol == ']':
            command = command_stack.pop() + command * multiplier_stack.pop()
        else:
            command += symbol

    return command


# второе решение с рекурсией


def get_decipher_command_2(short_command: str) -> str | tuple[str, int]:
    """
    Преобразование сокращенной инструкции в полную.(функция с рекурсией)
    Описание алгоритма:
    1. В функцию decipher_command передается короткая команда
    2. в decipher_command начинается посимвольная обработка полученной команды.
    2.1 Если символ - буква, то конкатенируем символ в полную комманду
    2.2 Если символ - число, то начинаем конкатенацией "собирать" полное
    число (number), т.к. оно может состоять из нескольких символов
    2.3 Cимвол == [ - рекурсивный случай, вызывается decipher_command,
    в качестве параметра передаем срез строки начиная со следующего элемента,
    после получения результата от выполнения базового случая рекурсии
    увеличиваем индекс на кол-во обработанных символов, а полученную
    команду дублируем number раз.
    2.4 Cимвол == ] - базовый случай для рекурсии, возвращаем tuple[str, int]:
    часть собранной комманды строку и индекс последнего символа подстроки
    3. Обработав все символы в decipher_command возвращаем полную комманду
    long_command(str)
    """

    indx = 0
    long_command = ''
    number = ''

    while indx < len(short_command):
        symbol = short_command[indx]
        indx += 1
        if symbol in NUMBERS_TEMPLATE:
            number += symbol
        elif symbol == '[':
            res = get_decipher_command_2(short_command[indx:])
            indx += res[1]
            long_command += res[0] * int(number)
            number = ''
        elif symbol == ']':
            return long_command, indx
        else:
            long_command += symbol

    return long_command


if __name__ == '__main__':
    short_command = input()
    long_command = get_decipher_command(short_command)
    long_command_2 = get_decipher_command_2(short_command)
    print(long_command, long_command_2, sep='\n')
