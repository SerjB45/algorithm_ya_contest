# Сортировка слиянием блоков

# Алгоритм предназначен для сортировки массивов длиной n, состоящих из
# уникальных чисел в диапазоне от 0 до n-1. Иными словами, массив
# должен содержать целые положительные числа от 0 до n-1, перемешанные
# как угодно.

# Суть алгоритма: исходный массив разделяется на блоки так, чтобы каждый блок
# можно было отсортировать и при слиянии отсортированных блоков получился
# отсортированный массив. Менять блоки местами нельзя.

# Алгоритм сортировки состоит из трёх шагов:
# 1. Разбить последовательность на k блоков. Блоки могут иметь разные размеры.
# Первый блок обязательно должен содержать 0.
# Если длина первого блока — r элементов, то максимальным значением в первом
# блоке должно быть число r - 1. А следующий блок (если он вообще будет)
# должен содержать число r. Принцип должен соблюдаться и в последующих блоках.
# 2. Отсортировать каждый из блоков.
# 3. Объединить блоки в единый массив.

# Такая сортировка выгодна в том случае, если разбить исходный массив на
# максимально возможное число блоков.


# Задание(реализация первого шага): написать программу, которая получает
# на вход массив и возвращает максимальное число блоков, на которое можно
# разбить этот массив так, чтобы сортировка отработала корректно.

# Формат ввода
# В первой строке задано n — количество чисел для сортировки (n ≤ 1000).
# В следующей строке записаны числа от 0 до n - 1.

# Формат вывода
# Выведите максимальное число блоков, на которое можно разбить данные
# при использовании метода частичной сортировки.

def main():
    n = int(input())  # noqa: F841
    lst = [int(i) for i in input().split()]

    print(max_blocks(lst))

# решение 1 - рабочее


def max_blocks(lst: list[int]):
    blocks = 0
    max_value = 0
    for i, val in enumerate(lst):
        max_value = max(max_value, val)
        if max_value == i:
            blocks += 1
    return blocks


if __name__ == '__main__':
    main()
